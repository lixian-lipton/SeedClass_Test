## 最终结果

**level : 4**

**（每一个 level 均保存了编译后文件）**


## 设计思路与实现历程

核心是 **事件驱动** 和 **状态管理** 。

整个编辑器运行在一个主循环中，不断地“刷新屏幕”和“处理用户输入”，并通过一个全局的`editorConfig`结构体来管理所有状态。

**实现历程大致分为以下几个阶段：**

1.  **基础搭建**：实现终端的 Raw 模式，能够读取单个按键并退出。
2.  **只读查看器**：实现文件打开、内容逐行显示、上下滚动以及欢迎界面。这个阶段确立了`erow`数据结构和屏幕绘制的基本逻辑。
3.  **核心编辑功能**：这是从“查看器”到“编辑器”的关键跃升。实现了字符和行的插入/删除、`dirty`标志、文件保存、退出确认等功能。
4.  **功能完善**：在核心功能之上，添加了“另存为”(`Save As`)、状态栏信息增强（如行号/总行数）等用户体验功能。
5.  **代码重构**：将底层的终端控制逻辑剥离到独立的`terminal.c`和`terminal.h`中，使主文件`main.c`更专注于编辑器本身的逻辑，提高了代码的模块化和可维护性。

然而，由于我每个 level 均在上一个 level 的 main.c 基础上直接增添修改而来，模块化设计不足（仅有原始模式设置独立于main）。

## 问题分析

主要挑战可以分为“显示”和“交互”两大块。

### 1. 显示：三层视图的转换

编辑器显示的难点在于正确处理、转换、兼顾三种不同视图：

*   **文件 (`file_position_x`, `file_position_y`)**：这是最原始的逻辑层。它代表光标在**文件内容**中的位置。

*   **渲染 (`screen_position_x`)**：这是视觉表现层。它解决了文件中的特殊字符（主要是`\t` Tab键）在屏幕上实际占据多宽的问题。一个Tab在文件中只算1个字符，但在屏幕上可能会变成多个空格。本人通过`editorRowFilePositionXToScreenPositionX`函数，模拟了从文件坐标到渲染坐标的转换，确保光标在含有 Tab 的行上也能准确定位。

*   **屏幕**：这是最终的物理显示层，需要通过种种ANSI转义序列正确处理。用户的终端窗口大小是固定的，只能显示文件的一部分。我通过`row_offset`和`column_offset`这两个变量来管理**滚动**，决定将文件的哪一部分显示在屏幕上。`editorScroll`函数负责在光标移动时自动更新这两个偏移量，实现平滑滚动。

三层之间的转换存在盲区和难点，

在开发过程中我遇到的一个 bug 就是，如果用户在一行中间输入回车，若只正确处理文件和渲染的坐标，忽略了清空光标后到行末的屏幕内容，那么就会出现新旧内容同时渲染的现象。

### 2. 交互：状态一致性

交互的挑战在于确保每一次用户操作都能正确、原子地更新所有相关状态。

*   **原子操作**：每个编辑操作（如删除字符）都可能涉及多个动作：修改行内容（`realloc`、`memmove`）、更新光标位置、更新`dirty`标志。这些必须作为一个整体成功或失败，不能留下不一致的中间状态。例如，在行首按退格键需要合并两行，这涉及字符串追加、删除一行、更新光标位置等多个步骤。

*   **状态管理 (`dirty`标志)**：引入`dirty`标志来追踪文件是否被修改。这个简单的整数标志是多个功能的基础：
    *   在状态栏显示 `(modified)`，提醒用户。
    *   在退出时（`Ctrl-Q`）触发“未保存更改”的警告。
    *   在成功保存后重置，完成一个完整的“编辑-保存”周期。

*   **防错设计**：对于可能导致数据丢失的破坏性操作（如退出未保存的文档），引入了**多次确认机制**。通过一个静态计数器`quit_times`，要求用户连续多次按下`Ctrl-Q`才能强制退出，极大地降低了误操作的风险。

*   **内存管理**：频繁的插入和删除操作要求高效的动态内存管理。项目中大量使用了`realloc`来动态调整行内容的缓冲区大小，并在`editorPrompt`中实现了缓冲区的动态扩容，以适应任意长度的文件名输入。
